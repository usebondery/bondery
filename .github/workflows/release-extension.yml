name: Release Chrome Extension

permissions:
  contents: write

on:
  push:
    tags:
      - "ext-v*.*.*" # Trigger on extension version tags like ext-v1.0.0, ext-v1.2.3
  workflow_dispatch: # Allow manual triggering
    inputs:
      release_tag:
        description: "Extension tag to release (format: ext-vX.Y.Z)"
        required: true
        type: string

jobs:
  build-and-release:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"

      - name: Install dependencies
        run: npm install

      - name: Resolve release metadata
        id: release_meta
        run: |
          if [ "${GITHUB_EVENT_NAME}" = "workflow_dispatch" ]; then
            TAG="${{ inputs.release_tag }}"
          else
            TAG="${GITHUB_REF_NAME}"
          fi

          if ! echo "$TAG" | grep -Eq '^ext-v[0-9]+\.[0-9]+\.[0-9]+$'; then
            echo "‚ùå Invalid release tag: $TAG"
            echo "Expected format: ext-vX.Y.Z"
            exit 1
          fi

          VERSION="${TAG#ext-v}"
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"

      - name: Ensure release tag exists for manual runs
        if: github.event_name == 'workflow_dispatch'
        run: |
          TAG="${{ steps.release_meta.outputs.tag }}"
          git fetch --tags
          if git rev-parse "$TAG" >/dev/null 2>&1; then
            echo "Tag already exists: $TAG"
          else
            git tag "$TAG" "$GITHUB_SHA"
            git push origin "$TAG"
          fi

      - name: Create production environment file
        run: |
          echo "NEXT_PUBLIC_WEBAPP_URL=${{ vars.NEXT_PUBLIC_WEBAPP_URL }}" > apps/chrome-extension/.env.production.local

      - name: Build Chrome Extension
        run: npx turbo build --filter=chrome-extension...
        env:
          NODE_ENV: production
          NEXT_PUBLIC_WEBAPP_URL: ${{ vars.NEXT_PUBLIC_WEBAPP_URL }}
          PRIVATE_CHROME_EXTENSION_ID: ${{ secrets.PRIVATE_CHROME_EXTENSION_ID }}
          PRIVATE_CHROME_CLIENT_ID: ${{ secrets.PRIVATE_CHROME_CLIENT_ID }}
          PRIVATE_CHROME_CLIENT_SECRET: ${{ secrets.PRIVATE_CHROME_CLIENT_SECRET }}
          PRIVATE_CHROME_REFRESH_TOKEN: ${{ secrets.PRIVATE_CHROME_REFRESH_TOKEN }}

      - name: Create signed CRX package
        run: |
          printf "%b" "${{ secrets.PRIVATE_CHROME_PRIVATE_SIGNING_KEY }}" > apps/chrome-extension/private-key.pem
          npx crx3@2 \
            -p apps/chrome-extension/private-key.pem \
            -o apps/chrome-extension/bondery-extension-${{ steps.release_meta.outputs.tag }}.crx \
            apps/chrome-extension/dist

      - name: Verify CRX signature inputs
        run: |
          printf "%b" "${{ secrets.PRIVATE_CHROME_PUBLIC_SIGNING_KEY }}" > apps/chrome-extension/public-key.pem

          openssl pkey -in apps/chrome-extension/private-key.pem -pubout -out apps/chrome-extension/derived-public-key.pem
          openssl pkey -pubin -in apps/chrome-extension/public-key.pem -outform DER > apps/chrome-extension/public-key.der
          openssl pkey -pubin -in apps/chrome-extension/derived-public-key.pem -outform DER > apps/chrome-extension/derived-public-key.der
          cmp -s apps/chrome-extension/public-key.der apps/chrome-extension/derived-public-key.der

          node -e "const fs=require('fs'); const crx=fs.readFileSync('apps/chrome-extension/bondery-extension-${{ steps.release_meta.outputs.tag }}.crx'); if(crx.subarray(0,4).toString()!=='Cr24'){ console.error('Invalid CRX header'); process.exit(1);}"

          EXPECTED_ID="${{ secrets.PRIVATE_CHROME_EXTENSION_ID }}"
          COMPUTED_ID=$(node -e "const fs=require('fs'); const crypto=require('crypto'); const der=fs.readFileSync('apps/chrome-extension/public-key.der'); const hex=crypto.createHash('sha256').update(der).digest('hex').slice(0,32); const map='abcdefghijklmnop'; let id=''; for (const ch of hex) id += map[parseInt(ch,16)]; process.stdout.write(id);")
          if [ "$COMPUTED_ID" != "$EXPECTED_ID" ]; then
            echo "‚ùå Signing key does not match extension id"
            echo "Computed: $COMPUTED_ID"
            echo "Expected: $EXPECTED_ID"
            exit 1
          fi

          rm -f apps/chrome-extension/public-key.pem apps/chrome-extension/derived-public-key.pem apps/chrome-extension/public-key.der apps/chrome-extension/derived-public-key.der
          rm -f apps/chrome-extension/private-key.pem

      - name: Create zip archive
        run: |
          cd apps/chrome-extension/dist
          zip -r ../../../bondery-extension-${{ steps.release_meta.outputs.tag }}.zip .
          cd ../../..

      - name: Upload CRX to Chrome Web Store
        run: |
          ACCESS_TOKEN=$(curl -sS -X POST https://oauth2.googleapis.com/token \
            -d client_id=${{ secrets.PRIVATE_CHROME_CLIENT_ID }} \
            -d client_secret=${{ secrets.PRIVATE_CHROME_CLIENT_SECRET }} \
            -d refresh_token=${{ secrets.PRIVATE_CHROME_REFRESH_TOKEN }} \
            -d grant_type=refresh_token | node -e "const fs=require('fs'); const input=fs.readFileSync(0,'utf8'); const data=JSON.parse(input); if(!data.access_token){ console.error(input); process.exit(1);} process.stdout.write(data.access_token);")

          UPLOAD_RESPONSE=$(curl -sS -X PUT \
            "https://www.googleapis.com/upload/chromewebstore/v1.1/items/${{ secrets.PRIVATE_CHROME_EXTENSION_ID }}" \
            -H "Authorization: Bearer $ACCESS_TOKEN" \
            -H "x-goog-api-version: 2" \
            -H "Content-Type: application/x-chrome-extension" \
            --data-binary @./apps/chrome-extension/bondery-extension-${{ steps.release_meta.outputs.tag }}.crx)

          echo "$UPLOAD_RESPONSE" | node -e "const fs=require('fs'); const input=fs.readFileSync(0,'utf8'); const data=JSON.parse(input); if(data.uploadState!=='SUCCESS'){ console.error(input); process.exit(1);}"

      - name: Publish Chrome Web Store item
        run: |
          ACCESS_TOKEN=$(curl -sS -X POST https://oauth2.googleapis.com/token \
            -d client_id=${{ secrets.PRIVATE_CHROME_CLIENT_ID }} \
            -d client_secret=${{ secrets.PRIVATE_CHROME_CLIENT_SECRET }} \
            -d refresh_token=${{ secrets.PRIVATE_CHROME_REFRESH_TOKEN }} \
            -d grant_type=refresh_token | node -e "const fs=require('fs'); const input=fs.readFileSync(0,'utf8'); const data=JSON.parse(input); if(!data.access_token){ console.error(input); process.exit(1);} process.stdout.write(data.access_token);")

          PUBLISH_RESPONSE=$(curl -sS -X POST \
            "https://www.googleapis.com/chromewebstore/v1.1/items/${{ secrets.PRIVATE_CHROME_EXTENSION_ID }}/publish" \
            -H "Authorization: Bearer $ACCESS_TOKEN" \
            -H "x-goog-api-version: 2")

          echo "$PUBLISH_RESPONSE" | node -e "const fs=require('fs'); const input=fs.readFileSync(0,'utf8'); const data=JSON.parse(input); const ok = data.status && (Array.isArray(data.status) ? data.status.includes('OK') : data.status==='OK'); if(!ok){ console.error(input); process.exit(1);}"

      - name: Create Release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.release_meta.outputs.tag }}
          release_name: Bondery Extension ${{ steps.release_meta.outputs.version }}
          body: |
            ## Bondery Chrome Extension Release ${{ steps.release_meta.outputs.version }}

            ### üéâ Automatic Chrome Web Store Publishing
            This version has been automatically published to the Chrome Web Store! You can install it directly from:
            [Bondery Social Integration - Chrome Web Store](https://chrome.google.com/webstore/detail/bondery-social-integration/${{ secrets.PRIVATE_CHROME_EXTENSION_ID }})

            ### Manual Installation (Development/Testing)
            If you need to install manually for development or testing:
            1. Download the `bondery-extension-${{ steps.release_meta.outputs.version }}.zip` file below
            2. Extract the zip file to a folder
            3. Open Chrome and navigate to `chrome://extensions/`
            4. Enable "Developer mode" in the top right corner
            5. Click "Load unpacked" and select the extracted folder

            ### Changes
            See the commit history for details on what's included in this release.
          draft: false
          prerelease: false

      - name: Upload Release Asset
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: ./bondery-extension-${{ steps.release_meta.outputs.tag }}.zip
          asset_name: bondery-extension-${{ steps.release_meta.outputs.version }}.zip
          asset_content_type: application/zip

      - name: Delete previous extension releases and tags
        run: |
          # Delete previous extension releases
          gh release list --limit 100 | grep "^ext-v" | awk '{print $1}' | while read tag; do
            if [ "$tag" != "${{ steps.release_meta.outputs.tag }}" ]; then
              echo "Deleting release: $tag"
              gh release delete "$tag" --yes || true
            fi
          done

          # Delete previous extension tags (keep current tag)
          git ls-remote --tags origin "ext-v*" | awk -F/ '{print $3}' | while read tag; do
            if [ "$tag" != "${{ steps.release_meta.outputs.tag }}" ]; then
              echo "Deleting tag: $tag"
              gh api -X DELETE "/repos/${{ github.repository }}/git/refs/tags/$tag" || true
            fi
          done
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
