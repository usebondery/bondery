name: Release Chrome Extension

permissions:
  contents: write

on:
  push:
    tags:
      - "ext-v*.*.*" # Trigger on extension version tags like ext-v1.0.0, ext-v1.2.3
  workflow_dispatch: # Allow manual triggering
    inputs:
      release_tag:
        description: "Extension tag to release (format: ext-vX.Y.Z)"
        required: true
        type: string

jobs:
  build-and-release:
    runs-on: ubuntu-latest
    env:
      NODE_ENV: production
      NEXT_PUBLIC_WEBAPP_URL: ${{ vars.NEXT_PUBLIC_WEBAPP_URL }}
      PRIVATE_CHROME_EXTENSION_ID: ${{ secrets.PRIVATE_CHROME_EXTENSION_ID }}
      PRIVATE_CHROME_PUBLISHER_ID: ${{ secrets.PRIVATE_CHROME_PUBLISHER_ID }}
      PRIVATE_CHROME_SERVICE_ACCOUNT_KEY_JSON: ${{ secrets.PRIVATE_CHROME_SERVICE_ACCOUNT_KEY_JSON }}
      PRIVATE_CHROME_PRIVATE_SIGNING_KEY: ${{ secrets.PRIVATE_CHROME_PRIVATE_SIGNING_KEY }}
      PRIVATE_CHROME_PUBLIC_SIGNING_KEY: ${{ secrets.PRIVATE_CHROME_PUBLIC_SIGNING_KEY }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Resolve release metadata
        id: release_meta
        run: |
          if [ "${GITHUB_EVENT_NAME}" = "workflow_dispatch" ]; then
            TAG="${{ inputs.release_tag }}"
          else
            TAG="${GITHUB_REF_NAME}"
          fi

          if ! echo "$TAG" | grep -Eq '^ext-v[0-9]+\.[0-9]+\.[0-9]+$'; then
            echo "‚ùå Invalid release tag: $TAG"
            echo "Expected format: ext-vX.Y.Z"
            exit 1
          fi

          VERSION="${TAG#ext-v}"
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"

      - name: Ensure release tag exists for manual runs
        if: github.event_name == 'workflow_dispatch'
        run: |
          TAG="${{ steps.release_meta.outputs.tag }}"
          git fetch --tags
          if git rev-parse "$TAG" >/dev/null 2>&1; then
            echo "Tag already exists: $TAG"
          else
            git tag "$TAG" "$GITHUB_SHA"
            git push origin "$TAG"
          fi

      - name: Create production environment file
        run: |
          echo "NEXT_PUBLIC_WEBAPP_URL=$NEXT_PUBLIC_WEBAPP_URL" > apps/chrome-extension/.env.production.local

      - name: Build Chrome Extension
        run: npx turbo build --filter=chrome-extension...

      - name: Validate keys, create signed CRX, and prepare public key asset
        run: |
          PRIVATE_KEY_PATH="apps/chrome-extension/private-key.pem"
          PUBLIC_KEY_PATH="apps/chrome-extension/public-key.pem"
          DERIVED_PUBLIC_KEY_PATH="apps/chrome-extension/derived-public-key.pem"
          PUBLIC_KEY_DER_PATH="apps/chrome-extension/public-key.der"
          DERIVED_PUBLIC_KEY_DER_PATH="apps/chrome-extension/derived-public-key.der"
          CRX_PATH="apps/chrome-extension/bondery-extension-${{ steps.release_meta.outputs.tag }}.crx"
          PUBLIC_KEY_ASSET_PATH="./bondery-extension-${{ steps.release_meta.outputs.tag }}.public-key.pem"

          printf "%b" "$PRIVATE_CHROME_PRIVATE_SIGNING_KEY" > "$PRIVATE_KEY_PATH"
          printf "%b" "$PRIVATE_CHROME_PUBLIC_SIGNING_KEY" > "$PUBLIC_KEY_PATH"

          openssl pkey -in "$PRIVATE_KEY_PATH" -pubout -out "$DERIVED_PUBLIC_KEY_PATH"
          openssl pkey -pubin -in "$PUBLIC_KEY_PATH" -outform DER > "$PUBLIC_KEY_DER_PATH"
          openssl pkey -pubin -in "$DERIVED_PUBLIC_KEY_PATH" -outform DER > "$DERIVED_PUBLIC_KEY_DER_PATH"

          if cmp -s "$PUBLIC_KEY_DER_PATH" "$DERIVED_PUBLIC_KEY_DER_PATH"; then
            echo "‚úÖ PRIVATE_CHROME_PRIVATE_SIGNING_KEY and PRIVATE_CHROME_PUBLIC_SIGNING_KEY match"
          else
            echo "‚ùå PRIVATE_CHROME_PRIVATE_SIGNING_KEY and PRIVATE_CHROME_PUBLIC_SIGNING_KEY do not match"
            exit 1
          fi

          npx crx3@2 \
            -p "$PRIVATE_KEY_PATH" \
            -o "$CRX_PATH" \
            apps/chrome-extension/dist

          cp "$PUBLIC_KEY_PATH" "$PUBLIC_KEY_ASSET_PATH"

          node -e "const fs=require('fs'); const crx=fs.readFileSync(process.argv[1]); if(crx.subarray(0,4).toString()!=='Cr24'){ console.error('Invalid CRX header'); process.exit(1);} " "$CRX_PATH"

          rm -f \
            "$PRIVATE_KEY_PATH" \
            "$PUBLIC_KEY_PATH" \
            "$DERIVED_PUBLIC_KEY_PATH" \
            "$PUBLIC_KEY_DER_PATH" \
            "$DERIVED_PUBLIC_KEY_DER_PATH"

      - name: Authenticate to Google Cloud
        id: gcp_auth
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ env.PRIVATE_CHROME_SERVICE_ACCOUNT_KEY_JSON }}
          token_format: access_token
          access_token_scopes: https://www.googleapis.com/auth/chromewebstore

      - name: Fetch Chrome Web Store item status
        run: |
          STATUS_RESPONSE=$(curl -sS -X GET \
            "https://chromewebstore.googleapis.com/v2/publishers/$PRIVATE_CHROME_PUBLISHER_ID/items/$PRIVATE_CHROME_EXTENSION_ID:fetchStatus" \
            -H "Authorization: Bearer ${{ steps.gcp_auth.outputs.access_token }}")

          echo "$STATUS_RESPONSE" | node -e "const fs=require('fs'); const input=fs.readFileSync(0,'utf8'); const data=JSON.parse(input); if(data.error){ console.error('‚ùå fetchStatus failed'); console.error(input); process.exit(1);} const itemState = data.itemState || 'UNKNOWN'; const uploadState = data.uploadState || 'UNKNOWN'; console.log(`‚úÖ fetchStatus OK | itemState=${itemState} uploadState=${uploadState}`);"

      - name: Create zip archive
        run: |
          cd apps/chrome-extension/dist
          zip -r ../../../bondery-extension-${{ steps.release_meta.outputs.tag }}.zip .
          cd ../../..

      - name: Upload CRX to Chrome Web Store
        run: |
          CRX_PATH="./apps/chrome-extension/bondery-extension-${{ steps.release_meta.outputs.tag }}.crx"
          CRX_FILE_NAME="bondery-extension-${{ steps.release_meta.outputs.version }}.crx"

          echo "CRX file diagnostics:"
          ls -lh "$CRX_PATH"
          node -e "const fs=require('fs'); const crypto=require('crypto'); const p=process.argv[1]; const b=fs.readFileSync(p); const magic=b.subarray(0,4).toString(); const version=b.readUInt32LE(4); const sha256=crypto.createHash('sha256').update(b).digest('hex'); console.log(JSON.stringify({path:p,sizeBytes:b.length,magic,version,sha256},null,2)); if(magic!=='Cr24'){ process.exit(1);} " "$CRX_PATH"

          HTTP_CODE=$(curl -sS -o /tmp/cws-upload-response.json -w "%{http_code}" -X POST \
            "https://chromewebstore.googleapis.com/upload/v2/publishers/$PRIVATE_CHROME_PUBLISHER_ID/items/$PRIVATE_CHROME_EXTENSION_ID:upload" \
            -H "Authorization: Bearer ${{ steps.gcp_auth.outputs.access_token }}" \
            -H "X-Goog-Upload-Protocol: raw" \
            -H "X-Goog-Upload-File-Name: $CRX_FILE_NAME" \
            -H "Content-Type: application/x-chrome-extension" \
            --data-binary @"$CRX_PATH")

          echo "Upload HTTP status: $HTTP_CODE"
          cat /tmp/cws-upload-response.json

          node -e "const fs=require('fs'); const code=Number(process.argv[1]); const input=fs.readFileSync('/tmp/cws-upload-response.json','utf8'); if(code < 200 || code >= 300){ console.error('Upload request failed with non-2xx status'); console.error(input); process.exit(1);} try { const data=JSON.parse(input); console.log('Upload response summary:', JSON.stringify({uploadState:data.uploadState, crxVersion:data.crxVersion}, null, 2)); } catch { console.log('Upload response was not JSON'); }" "$HTTP_CODE"

      - name: Publish Chrome Web Store item
        run: |
          PUBLISH_RESPONSE=$(curl -sS -X POST \
            "https://chromewebstore.googleapis.com/v2/publishers/$PRIVATE_CHROME_PUBLISHER_ID/items/$PRIVATE_CHROME_EXTENSION_ID:publish" \
            -H "Authorization: Bearer ${{ steps.gcp_auth.outputs.access_token }}")

          echo "$PUBLISH_RESPONSE" | node -e "const fs=require('fs'); const input=fs.readFileSync(0,'utf8'); const data=JSON.parse(input); const state=String(data.state||'').toUpperCase(); const status=data.status; const okStatus = Array.isArray(status) ? status.map(String).map(s=>s.toUpperCase()).includes('OK') : String(status||'').toUpperCase()==='OK'; const okState = ['PENDING_REVIEW','PUBLISHED'].includes(state); if(!(okStatus || okState)){ console.error(input); process.exit(1);} console.log('‚úÖ publish accepted | state=' + (state || 'UNKNOWN'));"

      - name: Create Release
        uses: softprops/action-gh-release@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.release_meta.outputs.tag }}
          name: Bondery Extension ${{ steps.release_meta.outputs.version }}
          body: |
            ## Bondery Chrome Extension Release ${{ steps.release_meta.outputs.version }}

            ### üéâ Automatic Chrome Web Store Publishing
            This version has been automatically published to the Chrome Web Store! You can install it directly from:
            [Bondery Social Integration - Chrome Web Store](https://chrome.google.com/webstore/detail/bondery-social-integration/${{ env.PRIVATE_CHROME_EXTENSION_ID }})

            ### Manual Installation (Development/Testing)
            If you need to install manually for development or testing:
            1. Download the release files below
            2. For unpacked mode, extract the `.zip` file to a folder
            3. Open Chrome and navigate to `chrome://extensions/`
            4. Enable "Developer mode" in the top right corner
            5. Click "Load unpacked" and select the extracted folder

            ### Changes
            See the commit history for details on what's included in this release.
          draft: false
          prerelease: false
          files: |
            ./bondery-extension-${{ steps.release_meta.outputs.tag }}.zip
            ./apps/chrome-extension/bondery-extension-${{ steps.release_meta.outputs.tag }}.crx
            ./bondery-extension-${{ steps.release_meta.outputs.tag }}.public-key.pem

      - name: Delete previous extension releases and tags
        run: |
          # Delete previous extension releases
          gh release list --limit 100 | grep "^ext-v" | awk '{print $1}' | while read tag; do
            if [ "$tag" != "${{ steps.release_meta.outputs.tag }}" ]; then
              echo "Deleting release: $tag"
              gh release delete "$tag" --yes || true
            fi
          done

          # Delete previous extension tags (keep current tag)
          git ls-remote --tags origin "ext-v*" | awk -F/ '{print $3}' | while read tag; do
            if [ "$tag" != "${{ steps.release_meta.outputs.tag }}" ]; then
              echo "Deleting tag: $tag"
              gh api -X DELETE "/repos/${{ github.repository }}/git/refs/tags/$tag" || true
            fi
          done
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
