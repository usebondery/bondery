name: Release Chrome Extension

permissions:
  contents: write

on:
  push:
    tags:
      - "ext-v*.*.*" # Trigger on extension version tags like ext-v1.0.0, ext-v1.2.3
  workflow_dispatch: # Allow manual triggering
    inputs:
      release_tag:
        description: "Extension tag to release (format: ext-vX.Y.Z)"
        required: true
        type: string

jobs:
  build-and-release:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: "npm"

      - name: Install dependencies
        run: npm install

      - name: Validate signing key pair from secrets
        run: |
          printf "%b" "${{ secrets.PRIVATE_CHROME_PRIVATE_SIGNING_KEY }}" > apps/chrome-extension/private-key-check.pem
          printf "%b" "${{ secrets.PRIVATE_CHROME_PUBLIC_SIGNING_KEY }}" > apps/chrome-extension/public-key-check.pem

          openssl pkey -in apps/chrome-extension/private-key-check.pem -pubout -out apps/chrome-extension/derived-public-key-check.pem
          openssl pkey -pubin -in apps/chrome-extension/public-key-check.pem -outform DER > apps/chrome-extension/public-key-check.der
          openssl pkey -pubin -in apps/chrome-extension/derived-public-key-check.pem -outform DER > apps/chrome-extension/derived-public-key-check.der

          if cmp -s apps/chrome-extension/public-key-check.der apps/chrome-extension/derived-public-key-check.der; then
            echo "âœ… PRIVATE_CHROME_PRIVATE_SIGNING_KEY and PRIVATE_CHROME_PUBLIC_SIGNING_KEY match"
          else
            echo "âŒ PRIVATE_CHROME_PRIVATE_SIGNING_KEY and PRIVATE_CHROME_PUBLIC_SIGNING_KEY do not match"
            exit 1
          fi

          rm -f \
            apps/chrome-extension/private-key-check.pem \
            apps/chrome-extension/public-key-check.pem \
            apps/chrome-extension/derived-public-key-check.pem \
            apps/chrome-extension/public-key-check.der \
            apps/chrome-extension/derived-public-key-check.der

      - name: Resolve release metadata
        id: release_meta
        run: |
          if [ "${GITHUB_EVENT_NAME}" = "workflow_dispatch" ]; then
            TAG="${{ inputs.release_tag }}"
          else
            TAG="${GITHUB_REF_NAME}"
          fi

          if ! echo "$TAG" | grep -Eq '^ext-v[0-9]+\.[0-9]+\.[0-9]+$'; then
            echo "âŒ Invalid release tag: $TAG"
            echo "Expected format: ext-vX.Y.Z"
            exit 1
          fi

          VERSION="${TAG#ext-v}"
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"

      - name: Ensure release tag exists for manual runs
        if: github.event_name == 'workflow_dispatch'
        run: |
          TAG="${{ steps.release_meta.outputs.tag }}"
          git fetch --tags
          if git rev-parse "$TAG" >/dev/null 2>&1; then
            echo "Tag already exists: $TAG"
          else
            git tag "$TAG" "$GITHUB_SHA"
            git push origin "$TAG"
          fi

      - name: Create production environment file
        run: |
          echo "NEXT_PUBLIC_WEBAPP_URL=${{ vars.NEXT_PUBLIC_WEBAPP_URL }}" > apps/chrome-extension/.env.production.local

      - name: Build Chrome Extension
        run: npx turbo build --filter=chrome-extension...
        env:
          NODE_ENV: production
          NEXT_PUBLIC_WEBAPP_URL: ${{ vars.NEXT_PUBLIC_WEBAPP_URL }}
          PRIVATE_CHROME_EXTENSION_ID: ${{ secrets.PRIVATE_CHROME_EXTENSION_ID }}
          PRIVATE_CHROME_PUBLISHER_ID: ${{ secrets.PRIVATE_CHROME_PUBLISHER_ID }}
          PRIVATE_CHROME_PROJECT_ID: ${{ secrets.PRIVATE_CHROME_PROJECT_ID }}
          PRIVATE_CHROME_SERVICE_ACCOUNT_EMAIL: ${{ secrets.PRIVATE_CHROME_SERVICE_ACCOUNT_EMAIL }}
          PRIVATE_CHROME_WORKLOAD_IDENTITY_PROVIDER: ${{ secrets.PRIVATE_CHROME_WORKLOAD_IDENTITY_PROVIDER }}
          PRIVATE_CHROME_PRIVATE_SIGNING_KEY: ${{ secrets.PRIVATE_CHROME_PRIVATE_SIGNING_KEY }}
          PRIVATE_CHROME_PUBLIC_SIGNING_KEY: ${{ secrets.PRIVATE_CHROME_PUBLIC_SIGNING_KEY }}

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.PRIVATE_CHROME_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.PRIVATE_CHROME_SERVICE_ACCOUNT_EMAIL }}

      - name: Setup gcloud
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ secrets.PRIVATE_CHROME_PROJECT_ID }}

      - name: Get Chrome Web Store access token
        id: cws_token
        run: |
          ACCESS_TOKEN=$(gcloud auth print-access-token \
            --impersonate-service-account=${{ secrets.PRIVATE_CHROME_SERVICE_ACCOUNT_EMAIL }} \
            --scopes=https://www.googleapis.com/auth/chromewebstore)

          echo "::add-mask::$ACCESS_TOKEN"
          echo "access_token=$ACCESS_TOKEN" >> "$GITHUB_OUTPUT"

      - name: Fetch Chrome Web Store item status
        run: |
          STATUS_RESPONSE=$(curl -sS -X GET \
            "https://chromewebstore.googleapis.com/v2/publishers/${{ secrets.PRIVATE_CHROME_PUBLISHER_ID }}/items/${{ secrets.PRIVATE_CHROME_EXTENSION_ID }}:fetchStatus" \
            -H "Authorization: Bearer ${{ steps.cws_token.outputs.access_token }}")

          echo "$STATUS_RESPONSE" | node -e "const fs=require('fs'); const input=fs.readFileSync(0,'utf8'); const data=JSON.parse(input); if(data.error){ console.error('âŒ fetchStatus failed'); console.error(input); process.exit(1);} const itemState = data.itemState || 'UNKNOWN'; const uploadState = data.uploadState || 'UNKNOWN'; console.log(`âœ… fetchStatus OK | itemState=${itemState} uploadState=${uploadState}`);"

      - name: Create signed CRX package
        run: |
          printf "%b" "${{ secrets.PRIVATE_CHROME_PRIVATE_SIGNING_KEY }}" > apps/chrome-extension/private-key.pem
          npx crx3@2 \
            -p apps/chrome-extension/private-key.pem \
            -o apps/chrome-extension/bondery-extension-${{ steps.release_meta.outputs.tag }}.crx \
            apps/chrome-extension/dist

      - name: Verify CRX signature inputs
        run: |
          printf "%b" "${{ secrets.PRIVATE_CHROME_PUBLIC_SIGNING_KEY }}" > apps/chrome-extension/public-key.pem

          openssl pkey -pubin -in apps/chrome-extension/public-key.pem -outform DER > apps/chrome-extension/public-key.der

          node -e "const fs=require('fs'); const crx=fs.readFileSync('apps/chrome-extension/bondery-extension-${{ steps.release_meta.outputs.tag }}.crx'); if(crx.subarray(0,4).toString()!=='Cr24'){ console.error('Invalid CRX header'); process.exit(1);}"

          rm -f apps/chrome-extension/public-key.pem apps/chrome-extension/public-key.der
          rm -f apps/chrome-extension/private-key.pem

      - name: Create zip archive
        run: |
          cd apps/chrome-extension/dist
          zip -r ../../../bondery-extension-${{ steps.release_meta.outputs.tag }}.zip .
          cd ../../..

      - name: Upload CRX to Chrome Web Store
        run: |
          UPLOAD_RESPONSE=$(curl -sS -X POST \
            "https://chromewebstore.googleapis.com/upload/v2/publishers/${{ secrets.PRIVATE_CHROME_PUBLISHER_ID }}/items/${{ secrets.PRIVATE_CHROME_EXTENSION_ID }}:upload" \
            -H "Authorization: Bearer ${{ steps.cws_token.outputs.access_token }}" \
            -H "Content-Type: application/x-chrome-extension" \
            --data-binary @./apps/chrome-extension/bondery-extension-${{ steps.release_meta.outputs.tag }}.crx)

          echo "$UPLOAD_RESPONSE" | node -e "const fs=require('fs'); const input=fs.readFileSync(0,'utf8'); const data=JSON.parse(input); if(data.uploadState!=='SUCCESS'){ console.error(input); process.exit(1);}"

      - name: Publish Chrome Web Store item
        run: |
          PUBLISH_RESPONSE=$(curl -sS -X POST \
            "https://chromewebstore.googleapis.com/v2/publishers/${{ secrets.PRIVATE_CHROME_PUBLISHER_ID }}/items/${{ secrets.PRIVATE_CHROME_EXTENSION_ID }}:publish" \
            -H "Authorization: Bearer ${{ steps.cws_token.outputs.access_token }}")

          echo "$PUBLISH_RESPONSE" | node -e "const fs=require('fs'); const input=fs.readFileSync(0,'utf8'); const data=JSON.parse(input); const ok = data.status && (Array.isArray(data.status) ? data.status.includes('OK') : data.status==='OK'); if(!ok){ console.error(input); process.exit(1);}"

      - name: Create Release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.release_meta.outputs.tag }}
          release_name: Bondery Extension ${{ steps.release_meta.outputs.version }}
          body: |
            ## Bondery Chrome Extension Release ${{ steps.release_meta.outputs.version }}

            ### ðŸŽ‰ Automatic Chrome Web Store Publishing
            This version has been automatically published to the Chrome Web Store! You can install it directly from:
            [Bondery Social Integration - Chrome Web Store](https://chrome.google.com/webstore/detail/bondery-social-integration/${{ secrets.PRIVATE_CHROME_EXTENSION_ID }})

            ### Manual Installation (Development/Testing)
            If you need to install manually for development or testing:
            1. Download the `bondery-extension-${{ steps.release_meta.outputs.version }}.zip` file below
            2. Extract the zip file to a folder
            3. Open Chrome and navigate to `chrome://extensions/`
            4. Enable "Developer mode" in the top right corner
            5. Click "Load unpacked" and select the extracted folder

            ### Changes
            See the commit history for details on what's included in this release.
          draft: false
          prerelease: false

      - name: Upload Release Asset
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: ./bondery-extension-${{ steps.release_meta.outputs.tag }}.zip
          asset_name: bondery-extension-${{ steps.release_meta.outputs.version }}.zip
          asset_content_type: application/zip

      - name: Delete previous extension releases and tags
        run: |
          # Delete previous extension releases
          gh release list --limit 100 | grep "^ext-v" | awk '{print $1}' | while read tag; do
            if [ "$tag" != "${{ steps.release_meta.outputs.tag }}" ]; then
              echo "Deleting release: $tag"
              gh release delete "$tag" --yes || true
            fi
          done

          # Delete previous extension tags (keep current tag)
          git ls-remote --tags origin "ext-v*" | awk -F/ '{print $3}' | while read tag; do
            if [ "$tag" != "${{ steps.release_meta.outputs.tag }}" ]; then
              echo "Deleting tag: $tag"
              gh api -X DELETE "/repos/${{ github.repository }}/git/refs/tags/$tag" || true
            fi
          done
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
